#pragma once 역활 : 같은 이름의 헤더파일은 한번만 가져오기
#define Book_Practice : Book_Practice를 정의합니다.
define함수이후 따로 쓰는게 없는데 뭘 정의하는 걸까?
해답 : 아무것도 정의하지 않고, 단지 해당 이름의 변수가 필요하다.
컴파일러는 같은 이름의 헤더를 2번 이상 include할 수 없다.
해당 이름의 변수를 만들어 이후의 다른 변수가 해당 변수가 이미 존재한다면 확인할 수 있도록 만든다.

1. define함수이후 따로 쓰는게 없는데 뭘 정의하는 걸까?

해답
아무것도 정의하지 않고, 단지 해당 이름의 변수가 필요하다.
컴파일러는 같은 이름의 헤더를 2번 이상 include할 수 없다.
해당 이름의 변수를 만들어 이후의 다른 변수가 해당 변수가 이미 존재한다면 확인할 수 있도록 만든다.

2. 한 구현 파일에 두 가지에 같은 헤더가 들어가 있는 것은 컴파일러가 오류를 내지만,
다른 구현 파일 파일에 같은 헤더가 들어가 있는 것은 오류를 내지 않는다.
#pragma once가 이것까지 잡아주는지는 모르겠다.

해답
다른 구현 파일의 헤더 중복은 걸러지지 않는다.
1. 메인에서 test2_1_h 헤더 파일안의 test2_2_h 헤더 파일을 불러 test2_3_h 중복 헤더파일을 부르려 하면 걸러진다.
2. 헤더파일에서 include한 파일을 구현파일에서 include하면 걸러진다.
3. 메인에서 test2_3_h를 include한 test2_1_h를 부르고 test2_3_h를 또 include하려면 걸러진다.
4. 메인에서 각 구현 파일에 test2_3_h include한 test2_1_h, test2_2_h를 부르는 건 걸러지지 않는다.

번역 단위(즉, .cpp 파일)는 개별적으로 처리되고 동일한 조건을 거칩니다.
번역 단위는 다른 번역 단위에서 발생하는 전처리기 정의를 공유하지 않습니다.
https://stackoverflow.com/questions/14909997/why-arent-my-include-guards-preventing-recursive-inclusion-and-multiple-symbol
즉, 구현 파일은 각각 개별로 컴파일 되므로 다른 파일에서 이미 include 된 헤더를 거를 수 없다.
그래서 링커는 2개의 파일에 같은 이름의 함수가 있어 오류를 낸다.

해결 방법
1. lnline 함수 사용
컴파일러에게 여러 번역 유닛에서 함수가 중복으로 정의되도 무시하고 하나 골라잡으라고 알려준다.
따로 구현파일에다 구현하지 않고 헤더에다가 inline함수로 만든다.
lnline함수로 중복 구현될 경우 이름만 같고 내용물이 달라질 수 있다.
2. static 키워드 사용
각 구현파일 마다 각각의 동일한 함수의 복제본을 가지게 된다.
즉, 함수 복제본이 구현 파일마다 있게된다.

3. 하나의 헤더의 하나의 구현파일 유지
